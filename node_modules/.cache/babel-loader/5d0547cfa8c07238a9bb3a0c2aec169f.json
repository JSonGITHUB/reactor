{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url_1 = require(\"url\");\n\nfunction validateSearchParams(searchParams) {\n  for (const value of Object.values(searchParams)) {\n    if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && value !== null) {\n      throw new TypeError(`The \\`searchParams\\` value '${String(value)}' must be a string, number, boolean or null`);\n    }\n  }\n}\n\nconst keys = ['protocol', 'username', 'password', 'host', 'hostname', 'port', 'pathname', 'search', 'hash'];\n\nexports.default = options => {\n  var _a, _b;\n\n  let origin;\n\n  if (options.path) {\n    if (options.pathname) {\n      throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n    }\n\n    if (options.search) {\n      throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n    }\n\n    if (options.searchParams) {\n      throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n    }\n  }\n\n  if (Reflect.has(options, 'auth')) {\n    throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');\n  }\n\n  if (options.search && options.searchParams) {\n    throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n  }\n\n  if (options.href) {\n    return new url_1.URL(options.href);\n  }\n\n  if (options.origin) {\n    origin = options.origin;\n  } else {\n    if (!options.protocol) {\n      throw new TypeError('No URL protocol specified');\n    }\n\n    origin = `${options.protocol}//${(_b = (_a = options.hostname, _a !== null && _a !== void 0 ? _a : options.host), _b !== null && _b !== void 0 ? _b : '')}`;\n  }\n\n  const url = new url_1.URL(origin);\n\n  if (options.path) {\n    const searchIndex = options.path.indexOf('?');\n\n    if (searchIndex === -1) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.slice(0, searchIndex);\n      options.search = options.path.slice(searchIndex + 1);\n    }\n  }\n\n  if (Reflect.has(options, 'path')) {\n    delete options.path;\n  }\n\n  for (const key of keys) {\n    if (Reflect.has(options, key)) {\n      url[key] = options[key].toString();\n    }\n  }\n\n  if (options.searchParams) {\n    if (typeof options.searchParams !== 'string' && !(options.searchParams instanceof url_1.URLSearchParams)) {\n      validateSearchParams(options.searchParams);\n    }\n\n    new url_1.URLSearchParams(options.searchParams).forEach((value, key) => {\n      url.searchParams.append(key, value);\n    });\n  }\n\n  return url;\n};","map":{"version":3,"sources":["/Users/js/Dev/my-first-reactor/node_modules/got/dist/source/utils/options-to-url.js"],"names":["Object","defineProperty","exports","value","url_1","require","validateSearchParams","searchParams","values","TypeError","String","keys","default","options","_a","_b","origin","path","pathname","search","Reflect","has","href","URL","protocol","hostname","host","url","searchIndex","indexOf","slice","key","toString","URLSearchParams","forEach","append"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nfunction validateSearchParams(searchParams) {\n    for (const value of Object.values(searchParams)) {\n        if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && value !== null) {\n            throw new TypeError(`The \\`searchParams\\` value '${String(value)}' must be a string, number, boolean or null`);\n        }\n    }\n}\nconst keys = [\n    'protocol',\n    'username',\n    'password',\n    'host',\n    'hostname',\n    'port',\n    'pathname',\n    'search',\n    'hash'\n];\nexports.default = (options) => {\n    var _a, _b;\n    let origin;\n    if (options.path) {\n        if (options.pathname) {\n            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n        }\n        if (options.search) {\n            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n        }\n        if (options.searchParams) {\n            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n        }\n    }\n    if (Reflect.has(options, 'auth')) {\n        throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');\n    }\n    if (options.search && options.searchParams) {\n        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n    }\n    if (options.href) {\n        return new url_1.URL(options.href);\n    }\n    if (options.origin) {\n        origin = options.origin;\n    }\n    else {\n        if (!options.protocol) {\n            throw new TypeError('No URL protocol specified');\n        }\n        origin = `${options.protocol}//${_b = (_a = options.hostname, (_a !== null && _a !== void 0 ? _a : options.host)), (_b !== null && _b !== void 0 ? _b : '')}`;\n    }\n    const url = new url_1.URL(origin);\n    if (options.path) {\n        const searchIndex = options.path.indexOf('?');\n        if (searchIndex === -1) {\n            options.pathname = options.path;\n        }\n        else {\n            options.pathname = options.path.slice(0, searchIndex);\n            options.search = options.path.slice(searchIndex + 1);\n        }\n    }\n    if (Reflect.has(options, 'path')) {\n        delete options.path;\n    }\n    for (const key of keys) {\n        if (Reflect.has(options, key)) {\n            url[key] = options[key].toString();\n        }\n    }\n    if (options.searchParams) {\n        if (typeof options.searchParams !== 'string' && !(options.searchParams instanceof url_1.URLSearchParams)) {\n            validateSearchParams(options.searchParams);\n        }\n        (new url_1.URLSearchParams(options.searchParams)).forEach((value, key) => {\n            url.searchParams.append(key, value);\n        });\n    }\n    return url;\n};\n"]},"metadata":{},"sourceType":"script"}