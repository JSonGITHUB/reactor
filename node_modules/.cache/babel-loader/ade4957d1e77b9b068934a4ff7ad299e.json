{"ast":null,"code":"'use strict';\n\nconst {\n  Resolver,\n  V4MAPPED,\n  ADDRCONFIG\n} = require('dns');\n\nconst {\n  promisify\n} = require('util');\n\nconst os = require('os');\n\nconst Keyv = require('keyv');\n\nconst kCacheableLookupData = Symbol('cacheableLookupData');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\n\nconst verifyAgent = agent => {\n  if (!(agent && typeof agent.createConnection === 'function')) {\n    throw new Error('Expected an Agent instance as the first argument');\n  }\n};\n\nconst map4to6 = entries => {\n  for (const entry of entries) {\n    entry.address = `::ffff:${entry.address}`;\n    entry.family = 6;\n  }\n};\n\nconst getIfaceInfo = () => {\n  let has4 = false;\n  let has6 = false;\n\n  for (const device of Object.values(os.networkInterfaces())) {\n    for (const iface of device) {\n      if (iface.internal) {\n        continue;\n      }\n\n      if (iface.family === 'IPv6') {\n        has6 = true;\n      } else {\n        has4 = true;\n      }\n\n      if (has4 && has6) {\n        break;\n      }\n    }\n  }\n\n  return {\n    has4,\n    has6\n  };\n};\n\nclass CacheableLookup {\n  constructor(options = {}) {\n    const {\n      cacheAdapter\n    } = options;\n    this.cache = new Keyv({\n      uri: typeof cacheAdapter === 'string' && cacheAdapter,\n      store: typeof cacheAdapter !== 'string' && cacheAdapter,\n      namespace: 'cached-lookup'\n    });\n    this.maxTtl = options.maxTtl === 0 ? 0 : options.maxTtl || Infinity;\n    this._resolver = options.resolver || new Resolver();\n    this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n    this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n    this.lookup = this.lookup.bind(this);\n    this.lookupAsync = this.lookupAsync.bind(this);\n  }\n\n  set servers(servers) {\n    this._resolver.setServers(servers);\n  }\n\n  get servers() {\n    return this._resolver.getServers();\n  }\n\n  lookup(hostname, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // eslint-disable-next-line promise/prefer-await-to-then\n\n\n    this.lookupAsync(hostname, { ...options,\n      throwNotFound: true\n    }).then(result => {\n      if (options.all) {\n        callback(null, result);\n      } else {\n        callback(null, result.address, result.family);\n      }\n    }).catch(callback);\n  }\n\n  async lookupAsync(hostname, options = {}) {\n    let cached;\n\n    if (!options.family && options.all) {\n      const [cached4, cached6] = await Promise.all([this.lookupAsync(hostname, {\n        all: true,\n        family: 4,\n        details: true\n      }), this.lookupAsync(hostname, {\n        all: true,\n        family: 6,\n        details: true\n      })]);\n      cached = [...cached4, ...cached6];\n    } else {\n      cached = await this.query(hostname, options.family || 4);\n\n      if (cached.length === 0 && options.family === 6 && options.hints & V4MAPPED) {\n        cached = await this.query(hostname, 4);\n        map4to6(cached);\n      }\n    }\n\n    if (options.hints & ADDRCONFIG) {\n      const {\n        has4,\n        has6\n      } = getIfaceInfo();\n      cached = cached.filter(entry => entry.family === 6 ? has6 : has4);\n    }\n\n    if (options.throwNotFound && cached.length === 0) {\n      const error = new Error(`ENOTFOUND ${hostname}`);\n      error.code = 'ENOTFOUND';\n      error.hostname = hostname;\n      throw error;\n    }\n\n    const now = Date.now();\n    cached = cached.filter(entry => !Reflect.has(entry, 'expires') || now < entry.expires);\n\n    if (!options.details) {\n      cached = cached.map(entry => {\n        return {\n          address: entry.address,\n          family: entry.family\n        };\n      });\n    }\n\n    if (options.all) {\n      return cached;\n    }\n\n    if (cached.length === 0) {\n      return undefined;\n    }\n\n    return this._getEntry(cached);\n  }\n\n  async query(hostname, family) {\n    let cached = await this.cache.get(`${hostname}:${family}`);\n\n    if (!cached) {\n      cached = await this.queryAndCache(hostname, family);\n    }\n\n    return cached;\n  }\n\n  async queryAndCache(hostname, family) {\n    const resolve = family === 4 ? this._resolve4 : this._resolve6;\n    const entries = await resolve(hostname, {\n      ttl: true\n    });\n\n    if (entries === undefined) {\n      return [];\n    }\n\n    const now = Date.now();\n    let cacheTtl = 0;\n\n    for (const entry of entries) {\n      cacheTtl = Math.max(cacheTtl, entry.ttl);\n      entry.family = family;\n\n      if (entry.ttl !== 0) {\n        entry.expires = now + entry.ttl * 1000;\n      }\n    }\n\n    cacheTtl = Math.min(this.maxTtl, cacheTtl) * 1000;\n\n    if (this.maxTtl !== 0 && cacheTtl !== 0) {\n      await this.cache.set(`${hostname}:${family}`, entries, cacheTtl);\n    }\n\n    return entries;\n  }\n\n  _getEntry(entries) {\n    return entries[Math.floor(Math.random() * entries.length)];\n  }\n\n  install(agent) {\n    verifyAgent(agent);\n\n    if (kCacheableLookupData in agent) {\n      throw new Error('CacheableLookup has been already installed');\n    }\n\n    agent[kCacheableLookupData] = agent.createConnection;\n    agent[kCacheableLookupInstance] = this;\n\n    agent.createConnection = (options, callback) => {\n      if (!('lookup' in options)) {\n        options.lookup = this.lookup;\n      }\n\n      return agent[kCacheableLookupData](options, callback);\n    };\n  }\n\n  uninstall(agent) {\n    verifyAgent(agent);\n\n    if (agent[kCacheableLookupData]) {\n      if (agent[kCacheableLookupInstance] !== this) {\n        throw new Error('The agent is not owned by this CacheableLookup instance');\n      }\n\n      agent.createConnection = agent[kCacheableLookupData];\n      delete agent[kCacheableLookupData];\n      delete agent[kCacheableLookupInstance];\n    }\n  }\n\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports.default = CacheableLookup;","map":{"version":3,"sources":["/Users/js/Dev/my-first-reactor/node_modules/cacheable-lookup/index.js"],"names":["Resolver","V4MAPPED","ADDRCONFIG","require","promisify","os","Keyv","kCacheableLookupData","Symbol","kCacheableLookupInstance","verifyAgent","agent","createConnection","Error","map4to6","entries","entry","address","family","getIfaceInfo","has4","has6","device","Object","values","networkInterfaces","iface","internal","CacheableLookup","constructor","options","cacheAdapter","cache","uri","store","namespace","maxTtl","Infinity","_resolver","resolver","_resolve4","resolve4","bind","_resolve6","resolve6","lookup","lookupAsync","servers","setServers","getServers","hostname","callback","throwNotFound","then","result","all","catch","cached","cached4","cached6","Promise","details","query","length","hints","filter","error","code","now","Date","Reflect","has","expires","map","undefined","_getEntry","get","queryAndCache","resolve","ttl","cacheTtl","Math","max","min","set","floor","random","install","uninstall","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\nconst {Resolver, V4MAPPED, ADDRCONFIG} = require('dns');\nconst {promisify} = require('util');\nconst os = require('os');\nconst Keyv = require('keyv');\n\nconst kCacheableLookupData = Symbol('cacheableLookupData');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\n\nconst verifyAgent = agent => {\n\tif (!(agent && typeof agent.createConnection === 'function')) {\n\t\tthrow new Error('Expected an Agent instance as the first argument');\n\t}\n};\n\nconst map4to6 = entries => {\n\tfor (const entry of entries) {\n\t\tentry.address = `::ffff:${entry.address}`;\n\t\tentry.family = 6;\n\t}\n};\n\nconst getIfaceInfo = () => {\n\tlet has4 = false;\n\tlet has6 = false;\n\n\tfor (const device of Object.values(os.networkInterfaces())) {\n\t\tfor (const iface of device) {\n\t\t\tif (iface.internal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iface.family === 'IPv6') {\n\t\t\t\thas6 = true;\n\t\t\t} else {\n\t\t\t\thas4 = true;\n\t\t\t}\n\n\t\t\tif (has4 && has6) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {has4, has6};\n};\n\nclass CacheableLookup {\n\tconstructor(options = {}) {\n\t\tconst {cacheAdapter} = options;\n\t\tthis.cache = new Keyv({\n\t\t\turi: typeof cacheAdapter === 'string' && cacheAdapter,\n\t\t\tstore: typeof cacheAdapter !== 'string' && cacheAdapter,\n\t\t\tnamespace: 'cached-lookup'\n\t\t});\n\n\t\tthis.maxTtl = options.maxTtl === 0 ? 0 : (options.maxTtl || Infinity);\n\n\t\tthis._resolver = options.resolver || new Resolver();\n\t\tthis._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n\t\tthis._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n\n\t\tthis.lookup = this.lookup.bind(this);\n\t\tthis.lookupAsync = this.lookupAsync.bind(this);\n\t}\n\n\tset servers(servers) {\n\t\tthis._resolver.setServers(servers);\n\t}\n\n\tget servers() {\n\t\treturn this._resolver.getServers();\n\t}\n\n\tlookup(hostname, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tthis.lookupAsync(hostname, {...options, throwNotFound: true}).then(result => {\n\t\t\tif (options.all) {\n\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tcallback(null, result.address, result.family);\n\t\t\t}\n\t\t}).catch(callback);\n\t}\n\n\tasync lookupAsync(hostname, options = {}) {\n\t\tlet cached;\n\t\tif (!options.family && options.all) {\n\t\t\tconst [cached4, cached6] = await Promise.all([this.lookupAsync(hostname, {all: true, family: 4, details: true}), this.lookupAsync(hostname, {all: true, family: 6, details: true})]);\n\t\t\tcached = [...cached4, ...cached6];\n\t\t} else {\n\t\t\tcached = await this.query(hostname, options.family || 4);\n\n\t\t\tif (cached.length === 0 && options.family === 6 && options.hints & V4MAPPED) {\n\t\t\t\tcached = await this.query(hostname, 4);\n\t\t\t\tmap4to6(cached);\n\t\t\t}\n\t\t}\n\n\t\tif (options.hints & ADDRCONFIG) {\n\t\t\tconst {has4, has6} = getIfaceInfo();\n\t\t\tcached = cached.filter(entry => entry.family === 6 ? has6 : has4);\n\t\t}\n\n\t\tif (options.throwNotFound && cached.length === 0) {\n\t\t\tconst error = new Error(`ENOTFOUND ${hostname}`);\n\t\t\terror.code = 'ENOTFOUND';\n\t\t\terror.hostname = hostname;\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\tcached = cached.filter(entry => !Reflect.has(entry, 'expires') || now < entry.expires);\n\n\t\tif (!options.details) {\n\t\t\tcached = cached.map(entry => {\n\t\t\t\treturn {\n\t\t\t\t\taddress: entry.address,\n\t\t\t\t\tfamily: entry.family\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (options.all) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tif (cached.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._getEntry(cached);\n\t}\n\n\tasync query(hostname, family) {\n\t\tlet cached = await this.cache.get(`${hostname}:${family}`);\n\t\tif (!cached) {\n\t\t\tcached = await this.queryAndCache(hostname, family);\n\t\t}\n\n\t\treturn cached;\n\t}\n\n\tasync queryAndCache(hostname, family) {\n\t\tconst resolve = family === 4 ? this._resolve4 : this._resolve6;\n\t\tconst entries = await resolve(hostname, {ttl: true});\n\n\t\tif (entries === undefined) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\tlet cacheTtl = 0;\n\t\tfor (const entry of entries) {\n\t\t\tcacheTtl = Math.max(cacheTtl, entry.ttl);\n\t\t\tentry.family = family;\n\n\t\t\tif (entry.ttl !== 0) {\n\t\t\t\tentry.expires = now + (entry.ttl * 1000);\n\t\t\t}\n\t\t}\n\n\t\tcacheTtl = Math.min(this.maxTtl, cacheTtl) * 1000;\n\n\t\tif (this.maxTtl !== 0 && cacheTtl !== 0) {\n\t\t\tawait this.cache.set(`${hostname}:${family}`, entries, cacheTtl);\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\t_getEntry(entries) {\n\t\treturn entries[Math.floor(Math.random() * entries.length)];\n\t}\n\n\tinstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (kCacheableLookupData in agent) {\n\t\t\tthrow new Error('CacheableLookup has been already installed');\n\t\t}\n\n\t\tagent[kCacheableLookupData] = agent.createConnection;\n\t\tagent[kCacheableLookupInstance] = this;\n\n\t\tagent.createConnection = (options, callback) => {\n\t\t\tif (!('lookup' in options)) {\n\t\t\t\toptions.lookup = this.lookup;\n\t\t\t}\n\n\t\t\treturn agent[kCacheableLookupData](options, callback);\n\t\t};\n\t}\n\n\tuninstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (agent[kCacheableLookupData]) {\n\t\t\tif (agent[kCacheableLookupInstance] !== this) {\n\t\t\t\tthrow new Error('The agent is not owned by this CacheableLookup instance');\n\t\t\t}\n\n\t\t\tagent.createConnection = agent[kCacheableLookupData];\n\n\t\t\tdelete agent[kCacheableLookupData];\n\t\t\tdelete agent[kCacheableLookupInstance];\n\t\t}\n\t}\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports.default = CacheableLookup;\n"]},"metadata":{},"sourceType":"script"}