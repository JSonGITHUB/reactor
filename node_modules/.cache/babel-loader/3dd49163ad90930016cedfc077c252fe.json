{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst EventEmitter = require(\"events\");\n\nconst getStream = require(\"get-stream\");\n\nconst PCancelable = require(\"p-cancelable\");\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst errors_1 = require(\"./errors\");\n\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\n\nconst request_as_event_emitter_1 = require(\"./request-as-event-emitter\");\n\nconst parseBody = (body, responseType, encoding) => {\n  if (responseType === 'json') {\n    return body.length === 0 ? '' : JSON.parse(body.toString());\n  }\n\n  if (responseType === 'buffer') {\n    return Buffer.from(body);\n  }\n\n  if (responseType === 'text') {\n    return body.toString(encoding);\n  }\n\n  throw new TypeError(`Unknown body type '${responseType}'`);\n};\n\nfunction createRejection(error) {\n  const promise = Promise.reject(error);\n\n  const returnPromise = () => promise;\n\n  promise.json = returnPromise;\n  promise.text = returnPromise;\n  promise.buffer = returnPromise;\n  promise.on = returnPromise;\n  return promise;\n}\n\nexports.createRejection = createRejection;\n\nfunction asPromise(options) {\n  const proxy = new EventEmitter();\n  let body;\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const emitter = request_as_event_emitter_1.default(options);\n    onCancel(emitter.abort);\n\n    const emitError = async error => {\n      try {\n        for (const hook of options.hooks.beforeError) {\n          // eslint-disable-next-line no-await-in-loop\n          error = await hook(error);\n        }\n\n        reject(error);\n      } catch (error_) {\n        reject(error_);\n      }\n    };\n\n    emitter.on('response', async response => {\n      var _a;\n\n      proxy.emit('response', response); // Download body\n\n      try {\n        body = await getStream.buffer(response, {\n          encoding: 'binary'\n        });\n      } catch (error) {\n        emitError(new errors_1.ReadError(error, options));\n        return;\n      }\n\n      if ((_a = response.req) === null || _a === void 0 ? void 0 : _a.aborted) {\n        // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n        return;\n      }\n\n      const isOk = () => {\n        const {\n          statusCode\n        } = response;\n        const limitStatusCode = options.followRedirect ? 299 : 399;\n        return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;\n      }; // Parse body\n\n\n      try {\n        response.body = parseBody(body, options.responseType, options.encoding);\n      } catch (error) {\n        // Fall back to `utf8`\n        response.body = body.toString();\n\n        if (isOk()) {\n          const parseError = new errors_1.ParseError(error, response, options);\n          emitError(parseError);\n          return;\n        }\n      }\n\n      try {\n        for (const [index, hook] of options.hooks.afterResponse.entries()) {\n          // @ts-ignore TS doesn't notice that CancelableRequest is a Promise\n          // eslint-disable-next-line no-await-in-loop\n          response = await hook(response, async updatedOptions => {\n            const typedOptions = normalize_arguments_1.normalizeArguments(normalize_arguments_1.mergeOptions(options, { ...updatedOptions,\n              retry: {\n                calculateDelay: () => 0\n              },\n              throwHttpErrors: false,\n              resolveBodyOnly: false\n            })); // Remove any further hooks for that request, because we'll call them anyway.\n            // The loop continues. We don't want duplicates (asPromise recursion).\n\n            typedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n\n            for (const hook of options.hooks.beforeRetry) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(typedOptions);\n            }\n\n            const promise = asPromise(typedOptions);\n            onCancel(() => {\n              promise.catch(() => {});\n              promise.cancel();\n            });\n            return promise;\n          });\n        }\n      } catch (error) {\n        emitError(error);\n        return;\n      } // Check for HTTP error codes\n\n\n      if (!isOk()) {\n        const error = new errors_1.HTTPError(response, options);\n\n        if (emitter.retry(error)) {\n          return;\n        }\n\n        if (options.throwHttpErrors) {\n          emitError(error);\n          return;\n        }\n      }\n\n      resolve(options.resolveBodyOnly ? response.body : response);\n    });\n    emitter.once('error', reject);\n    request_as_event_emitter_1.proxyEvents(proxy, emitter);\n  });\n\n  promise.on = (name, fn) => {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  const shortcut = responseType => {\n    // eslint-disable-next-line promise/prefer-await-to-then\n    const newPromise = promise.then(() => parseBody(body, responseType, options.encoding));\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n\n  promise.json = () => {\n    if (is_1.default.undefined(body) && is_1.default.undefined(options.headers.accept)) {\n      options.headers.accept = 'application/json';\n    }\n\n    return shortcut('json');\n  };\n\n  promise.buffer = () => shortcut('buffer');\n\n  promise.text = () => shortcut('text');\n\n  return promise;\n}\n\nexports.default = asPromise;","map":{"version":3,"sources":["/Users/js/Dev/my-first-reactor/node_modules/got/dist/source/as-promise.js"],"names":["Object","defineProperty","exports","value","EventEmitter","require","getStream","PCancelable","is_1","errors_1","normalize_arguments_1","request_as_event_emitter_1","parseBody","body","responseType","encoding","length","JSON","parse","toString","Buffer","from","TypeError","createRejection","error","promise","Promise","reject","returnPromise","json","text","buffer","on","asPromise","options","proxy","resolve","onCancel","emitter","default","abort","emitError","hook","hooks","beforeError","error_","response","_a","emit","ReadError","req","aborted","isOk","statusCode","limitStatusCode","followRedirect","parseError","ParseError","index","afterResponse","entries","updatedOptions","typedOptions","normalizeArguments","mergeOptions","retry","calculateDelay","throwHttpErrors","resolveBodyOnly","slice","beforeRetry","catch","cancel","HTTPError","once","proxyEvents","name","fn","shortcut","newPromise","then","defineProperties","getOwnPropertyDescriptors","undefined","headers","accept"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"events\");\nconst getStream = require(\"get-stream\");\nconst PCancelable = require(\"p-cancelable\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst errors_1 = require(\"./errors\");\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\nconst request_as_event_emitter_1 = require(\"./request-as-event-emitter\");\nconst parseBody = (body, responseType, encoding) => {\n    if (responseType === 'json') {\n        return body.length === 0 ? '' : JSON.parse(body.toString());\n    }\n    if (responseType === 'buffer') {\n        return Buffer.from(body);\n    }\n    if (responseType === 'text') {\n        return body.toString(encoding);\n    }\n    throw new TypeError(`Unknown body type '${responseType}'`);\n};\nfunction createRejection(error) {\n    const promise = Promise.reject(error);\n    const returnPromise = () => promise;\n    promise.json = returnPromise;\n    promise.text = returnPromise;\n    promise.buffer = returnPromise;\n    promise.on = returnPromise;\n    return promise;\n}\nexports.createRejection = createRejection;\nfunction asPromise(options) {\n    const proxy = new EventEmitter();\n    let body;\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const emitter = request_as_event_emitter_1.default(options);\n        onCancel(emitter.abort);\n        const emitError = async (error) => {\n            try {\n                for (const hook of options.hooks.beforeError) {\n                    // eslint-disable-next-line no-await-in-loop\n                    error = await hook(error);\n                }\n                reject(error);\n            }\n            catch (error_) {\n                reject(error_);\n            }\n        };\n        emitter.on('response', async (response) => {\n            var _a;\n            proxy.emit('response', response);\n            // Download body\n            try {\n                body = await getStream.buffer(response, { encoding: 'binary' });\n            }\n            catch (error) {\n                emitError(new errors_1.ReadError(error, options));\n                return;\n            }\n            if ((_a = response.req) === null || _a === void 0 ? void 0 : _a.aborted) {\n                // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                return;\n            }\n            const isOk = () => {\n                const { statusCode } = response;\n                const limitStatusCode = options.followRedirect ? 299 : 399;\n                return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;\n            };\n            // Parse body\n            try {\n                response.body = parseBody(body, options.responseType, options.encoding);\n            }\n            catch (error) {\n                // Fall back to `utf8`\n                response.body = body.toString();\n                if (isOk()) {\n                    const parseError = new errors_1.ParseError(error, response, options);\n                    emitError(parseError);\n                    return;\n                }\n            }\n            try {\n                for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                    // @ts-ignore TS doesn't notice that CancelableRequest is a Promise\n                    // eslint-disable-next-line no-await-in-loop\n                    response = await hook(response, async (updatedOptions) => {\n                        const typedOptions = normalize_arguments_1.normalizeArguments(normalize_arguments_1.mergeOptions(options, {\n                            ...updatedOptions,\n                            retry: {\n                                calculateDelay: () => 0\n                            },\n                            throwHttpErrors: false,\n                            resolveBodyOnly: false\n                        }));\n                        // Remove any further hooks for that request, because we'll call them anyway.\n                        // The loop continues. We don't want duplicates (asPromise recursion).\n                        typedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                        for (const hook of options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(typedOptions);\n                        }\n                        const promise = asPromise(typedOptions);\n                        onCancel(() => {\n                            promise.catch(() => { });\n                            promise.cancel();\n                        });\n                        return promise;\n                    });\n                }\n            }\n            catch (error) {\n                emitError(error);\n                return;\n            }\n            // Check for HTTP error codes\n            if (!isOk()) {\n                const error = new errors_1.HTTPError(response, options);\n                if (emitter.retry(error)) {\n                    return;\n                }\n                if (options.throwHttpErrors) {\n                    emitError(error);\n                    return;\n                }\n            }\n            resolve(options.resolveBodyOnly ? response.body : response);\n        });\n        emitter.once('error', reject);\n        request_as_event_emitter_1.proxyEvents(proxy, emitter);\n    });\n    promise.on = (name, fn) => {\n        proxy.on(name, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        // eslint-disable-next-line promise/prefer-await-to-then\n        const newPromise = promise.then(() => parseBody(body, responseType, options.encoding));\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (is_1.default.undefined(body) && is_1.default.undefined(options.headers.accept)) {\n            options.headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports.default = asPromise;\n"]},"metadata":{},"sourceType":"script"}