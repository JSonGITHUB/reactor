{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst duplexer3 = require(\"duplexer3\");\n\nconst http_1 = require(\"http\");\n\nconst stream_1 = require(\"stream\");\n\nconst errors_1 = require(\"./errors\");\n\nconst request_as_event_emitter_1 = require(\"./request-as-event-emitter\");\n\nclass ProxyStream extends stream_1.Duplex {}\n\nexports.ProxyStream = ProxyStream;\n\nfunction asStream(options) {\n  const input = new stream_1.PassThrough();\n  const output = new stream_1.PassThrough();\n  const proxy = duplexer3(input, output);\n  const piped = new Set();\n  let isFinished = false;\n\n  options.retry.calculateDelay = () => 0;\n\n  if (options.body || options.json || options.form) {\n    proxy.write = () => {\n      proxy.destroy();\n      throw new Error('Got\\'s stream is not writable when the `body`, `json` or `form` option is used');\n    };\n  } else if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {\n    options.body = input;\n  } else {\n    proxy.write = () => {\n      proxy.destroy();\n      throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n    };\n  }\n\n  const emitter = request_as_event_emitter_1.default(options);\n\n  const emitError = async error => {\n    try {\n      for (const hook of options.hooks.beforeError) {\n        // eslint-disable-next-line no-await-in-loop\n        error = await hook(error);\n      }\n\n      proxy.emit('error', error);\n    } catch (error_) {\n      proxy.emit('error', error_);\n    }\n  }; // Cancels the request\n\n\n  proxy._destroy = (error, callback) => {\n    callback(error);\n    emitter.abort();\n  };\n\n  emitter.on('response', response => {\n    const {\n      statusCode,\n      isFromCache\n    } = response;\n    proxy.isFromCache = isFromCache;\n\n    if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n      emitError(new errors_1.HTTPError(response, options));\n      return;\n    }\n\n    {\n      const read = proxy._read;\n\n      proxy._read = (...args) => {\n        isFinished = true;\n        proxy._read = read;\n        return read.apply(proxy, args);\n      };\n    }\n\n    if (options.encoding) {\n      proxy.setEncoding(options.encoding);\n    } // We cannot use `stream.pipeline(...)` here,\n    // because if we did then `output` would throw\n    // the original error before throwing `ReadError`.\n\n\n    response.pipe(output);\n    response.once('error', error => {\n      emitError(new errors_1.ReadError(error, options));\n    });\n\n    for (const destination of piped) {\n      if (destination.headersSent) {\n        continue;\n      }\n\n      for (const [key, value] of Object.entries(response.headers)) {\n        // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n        // It's not possible to decompress already decompressed data, is it?\n        const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n\n        if (isAllowed) {\n          destination.setHeader(key, value);\n        }\n      }\n\n      destination.statusCode = response.statusCode;\n    }\n\n    proxy.emit('response', response);\n  });\n  request_as_event_emitter_1.proxyEvents(proxy, emitter);\n  emitter.on('error', error => proxy.emit('error', error));\n  const pipe = proxy.pipe.bind(proxy);\n  const unpipe = proxy.unpipe.bind(proxy);\n\n  proxy.pipe = (destination, options) => {\n    if (isFinished) {\n      throw new Error('Failed to pipe. The response has been emitted already.');\n    }\n\n    pipe(destination, options);\n\n    if (destination instanceof http_1.ServerResponse) {\n      piped.add(destination);\n    }\n\n    return destination;\n  };\n\n  proxy.unpipe = stream => {\n    piped.delete(stream);\n    return unpipe(stream);\n  };\n\n  proxy.on('pipe', source => {\n    if (source instanceof http_1.IncomingMessage) {\n      options.headers = { ...source.headers,\n        ...options.headers\n      };\n    }\n  });\n  proxy.isFromCache = undefined;\n  return proxy;\n}\n\nexports.default = asStream;","map":{"version":3,"sources":["/Users/js/Dev/my-first-reactor/node_modules/got/dist/source/as-stream.js"],"names":["Object","defineProperty","exports","value","duplexer3","require","http_1","stream_1","errors_1","request_as_event_emitter_1","ProxyStream","Duplex","asStream","options","input","PassThrough","output","proxy","piped","Set","isFinished","retry","calculateDelay","body","json","form","write","destroy","Error","method","TypeError","emitter","default","emitError","error","hook","hooks","beforeError","emit","error_","_destroy","callback","abort","on","response","statusCode","isFromCache","throwHttpErrors","HTTPError","read","_read","args","apply","encoding","setEncoding","pipe","once","ReadError","destination","headersSent","key","entries","headers","isAllowed","decompress","setHeader","proxyEvents","bind","unpipe","ServerResponse","add","stream","delete","source","IncomingMessage","undefined"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst duplexer3 = require(\"duplexer3\");\nconst http_1 = require(\"http\");\nconst stream_1 = require(\"stream\");\nconst errors_1 = require(\"./errors\");\nconst request_as_event_emitter_1 = require(\"./request-as-event-emitter\");\nclass ProxyStream extends stream_1.Duplex {\n}\nexports.ProxyStream = ProxyStream;\nfunction asStream(options) {\n    const input = new stream_1.PassThrough();\n    const output = new stream_1.PassThrough();\n    const proxy = duplexer3(input, output);\n    const piped = new Set();\n    let isFinished = false;\n    options.retry.calculateDelay = () => 0;\n    if (options.body || options.json || options.form) {\n        proxy.write = () => {\n            proxy.destroy();\n            throw new Error('Got\\'s stream is not writable when the `body`, `json` or `form` option is used');\n        };\n    }\n    else if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {\n        options.body = input;\n    }\n    else {\n        proxy.write = () => {\n            proxy.destroy();\n            throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n        };\n    }\n    const emitter = request_as_event_emitter_1.default(options);\n    const emitError = async (error) => {\n        try {\n            for (const hook of options.hooks.beforeError) {\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n            proxy.emit('error', error);\n        }\n        catch (error_) {\n            proxy.emit('error', error_);\n        }\n    };\n    // Cancels the request\n    proxy._destroy = (error, callback) => {\n        callback(error);\n        emitter.abort();\n    };\n    emitter.on('response', (response) => {\n        const { statusCode, isFromCache } = response;\n        proxy.isFromCache = isFromCache;\n        if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n            emitError(new errors_1.HTTPError(response, options));\n            return;\n        }\n        {\n            const read = proxy._read;\n            proxy._read = (...args) => {\n                isFinished = true;\n                proxy._read = read;\n                return read.apply(proxy, args);\n            };\n        }\n        if (options.encoding) {\n            proxy.setEncoding(options.encoding);\n        }\n        // We cannot use `stream.pipeline(...)` here,\n        // because if we did then `output` would throw\n        // the original error before throwing `ReadError`.\n        response.pipe(output);\n        response.once('error', error => {\n            emitError(new errors_1.ReadError(error, options));\n        });\n        for (const destination of piped) {\n            if (destination.headersSent) {\n                continue;\n            }\n            for (const [key, value] of Object.entries(response.headers)) {\n                // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n                // It's not possible to decompress already decompressed data, is it?\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = response.statusCode;\n        }\n        proxy.emit('response', response);\n    });\n    request_as_event_emitter_1.proxyEvents(proxy, emitter);\n    emitter.on('error', (error) => proxy.emit('error', error));\n    const pipe = proxy.pipe.bind(proxy);\n    const unpipe = proxy.unpipe.bind(proxy);\n    proxy.pipe = (destination, options) => {\n        if (isFinished) {\n            throw new Error('Failed to pipe. The response has been emitted already.');\n        }\n        pipe(destination, options);\n        if (destination instanceof http_1.ServerResponse) {\n            piped.add(destination);\n        }\n        return destination;\n    };\n    proxy.unpipe = stream => {\n        piped.delete(stream);\n        return unpipe(stream);\n    };\n    proxy.on('pipe', source => {\n        if (source instanceof http_1.IncomingMessage) {\n            options.headers = {\n                ...source.headers,\n                ...options.headers\n            };\n        }\n    });\n    proxy.isFromCache = undefined;\n    return proxy;\n}\nexports.default = asStream;\n"]},"metadata":{},"sourceType":"script"}