{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net = require(\"net\");\n\nconst unhandle_1 = require(\"./unhandle\");\n\nconst reentry = Symbol('reentry');\n\nconst noop = () => {};\n\nclass TimeoutError extends Error {\n  constructor(threshold, event) {\n    super(`Timeout awaiting '${event}' for ${threshold}ms`);\n    this.event = event;\n    this.name = 'TimeoutError';\n    this.code = 'ETIMEDOUT';\n  }\n\n}\n\nexports.TimeoutError = TimeoutError;\n\nexports.default = (request, delays, options) => {\n  if (Reflect.has(request, reentry)) {\n    return noop;\n  }\n\n  request[reentry] = true;\n  const cancelers = [];\n  const {\n    once,\n    unhandleAll\n  } = unhandle_1.default();\n\n  const addTimeout = (delay, callback, event) => {\n    var _a, _b;\n\n    const timeout = setTimeout(callback, delay, delay, event);\n    (_b = (_a = timeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    const cancel = () => {\n      clearTimeout(timeout);\n    };\n\n    cancelers.push(cancel);\n    return cancel;\n  };\n\n  const {\n    host,\n    hostname\n  } = options;\n\n  const timeoutHandler = (delay, event) => {\n    if (request.socket) {\n      // @ts-ignore We do not want the `socket hang up` error\n      request.socket._hadError = true;\n    }\n\n    request.abort();\n    request.emit('error', new TimeoutError(delay, event));\n  };\n\n  const cancelTimeouts = () => {\n    for (const cancel of cancelers) {\n      cancel();\n    }\n\n    unhandleAll();\n  };\n\n  request.once('error', error => {\n    cancelTimeouts(); // Save original behavior\n\n    if (request.listenerCount('error') === 0) {\n      throw error;\n    }\n  });\n  request.once('abort', cancelTimeouts);\n  once(request, 'response', response => {\n    once(response, 'end', cancelTimeouts);\n  });\n\n  if (typeof delays.request !== 'undefined') {\n    addTimeout(delays.request, timeoutHandler, 'request');\n  }\n\n  if (typeof delays.socket !== 'undefined') {\n    const socketTimeoutHandler = () => {\n      timeoutHandler(delays.socket, 'socket');\n    };\n\n    request.setTimeout(delays.socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n\n    cancelers.push(() => {\n      request.removeListener('timeout', socketTimeoutHandler);\n    });\n  }\n\n  once(request, 'socket', socket => {\n    var _a; // @ts-ignore Node typings doesn't have this property\n\n\n    const {\n      socketPath\n    } = request;\n    /* istanbul ignore next: hard to test */\n\n    if (socket.connecting) {\n      const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host, _a !== null && _a !== void 0 ? _a : '')) !== 0);\n\n      if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n        const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n        once(socket, 'lookup', cancelTimeout);\n      }\n\n      if (typeof delays.connect !== 'undefined') {\n        const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n\n        if (hasPath) {\n          once(socket, 'connect', timeConnect());\n        } else {\n          once(socket, 'lookup', error => {\n            if (error === null) {\n              once(socket, 'connect', timeConnect());\n            }\n          });\n        }\n      }\n\n      if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n        once(socket, 'connect', () => {\n          const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n          once(socket, 'secureConnect', cancelTimeout);\n        });\n      }\n    }\n\n    if (typeof delays.send !== 'undefined') {\n      const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        once(socket, 'connect', () => {\n          once(request, 'upload-complete', timeRequest());\n        });\n      } else {\n        once(request, 'upload-complete', timeRequest());\n      }\n    }\n  });\n\n  if (typeof delays.response !== 'undefined') {\n    once(request, 'upload-complete', () => {\n      const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      once(request, 'response', cancelTimeout);\n    });\n  }\n\n  return cancelTimeouts;\n};","map":{"version":3,"sources":["/Users/js/Dev/my-first-reactor/node_modules/got/dist/source/utils/timed-out.js"],"names":["Object","defineProperty","exports","value","net","require","unhandle_1","reentry","Symbol","noop","TimeoutError","Error","constructor","threshold","event","name","code","default","request","delays","options","Reflect","has","cancelers","once","unhandleAll","addTimeout","delay","callback","_a","_b","timeout","setTimeout","unref","call","cancel","clearTimeout","push","host","hostname","timeoutHandler","socket","_hadError","abort","emit","cancelTimeouts","error","listenerCount","response","socketTimeoutHandler","removeListener","socketPath","connecting","hasPath","Boolean","isIP","lookup","address","cancelTimeout","connect","timeConnect","secureConnect","protocol","send","timeRequest"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net = require(\"net\");\nconst unhandle_1 = require(\"./unhandle\");\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nclass TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        this.event = event;\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexports.TimeoutError = TimeoutError;\nexports.default = (request, delays, options) => {\n    if (Reflect.has(request, reentry)) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandle_1.default();\n    const addTimeout = (delay, callback, event) => {\n        var _a, _b;\n        const timeout = setTimeout(callback, delay, delay, event);\n        (_b = (_a = timeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        const cancel = () => {\n            clearTimeout(timeout);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        if (request.socket) {\n            // @ts-ignore We do not want the `socket hang up` error\n            request.socket._hadError = true;\n        }\n        request.abort();\n        request.emit('error', new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    request.once('abort', cancelTimeouts);\n    once(request, 'response', (response) => {\n        once(response, 'end', cancelTimeouts);\n    });\n    if (typeof delays.request !== 'undefined') {\n        addTimeout(delays.request, timeoutHandler, 'request');\n    }\n    if (typeof delays.socket !== 'undefined') {\n        const socketTimeoutHandler = () => {\n            timeoutHandler(delays.socket, 'socket');\n        };\n        request.setTimeout(delays.socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    once(request, 'socket', (socket) => {\n        var _a;\n        // @ts-ignore Node typings doesn't have this property\n        const { socketPath } = request;\n        /* istanbul ignore next: hard to test */\n        if (socket.connecting) {\n            const hasPath = Boolean((socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = (hostname !== null && hostname !== void 0 ? hostname : host), (_a !== null && _a !== void 0 ? _a : ''))) !== 0));\n            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                once(socket, 'lookup', cancelTimeout);\n            }\n            if (typeof delays.connect !== 'undefined') {\n                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                if (hasPath) {\n                    once(socket, 'connect', timeConnect());\n                }\n                else {\n                    once(socket, 'lookup', (error) => {\n                        if (error === null) {\n                            once(socket, 'connect', timeConnect());\n                        }\n                    });\n                }\n            }\n            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n                once(socket, 'connect', () => {\n                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                    once(socket, 'secureConnect', cancelTimeout);\n                });\n            }\n        }\n        if (typeof delays.send !== 'undefined') {\n            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                once(socket, 'connect', () => {\n                    once(request, 'upload-complete', timeRequest());\n                });\n            }\n            else {\n                once(request, 'upload-complete', timeRequest());\n            }\n        }\n    });\n    if (typeof delays.response !== 'undefined') {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n};\n"]},"metadata":{},"sourceType":"script"}