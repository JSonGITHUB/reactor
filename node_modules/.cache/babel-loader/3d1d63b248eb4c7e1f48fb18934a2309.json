{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst CacheableRequest = require(\"cacheable-request\");\n\nconst EventEmitter = require(\"events\");\n\nconst http = require(\"http\");\n\nconst stream = require(\"stream\");\n\nconst url_1 = require(\"url\");\n\nconst util_1 = require(\"util\");\n\nconst is_1 = require(\"@sindresorhus/is\");\n\nconst http_timer_1 = require(\"@szmarczak/http-timer\");\n\nconst calculate_retry_delay_1 = require(\"./calculate-retry-delay\");\n\nconst errors_1 = require(\"./errors\");\n\nconst get_response_1 = require(\"./get-response\");\n\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\n\nconst progress_1 = require(\"./progress\");\n\nconst timed_out_1 = require(\"./utils/timed-out\");\n\nconst types_1 = require(\"./types\");\n\nconst url_to_options_1 = require(\"./utils/url-to-options\");\n\nconst setImmediateAsync = async () => new Promise(resolve => setImmediate(resolve));\n\nconst pipeline = util_1.promisify(stream.pipeline);\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\n\nexports.default = options => {\n  const emitter = new EventEmitter();\n  const requestUrl = options.url.toString();\n  const redirects = [];\n  let retryCount = 0;\n  let currentRequest; // `request.aborted` is a boolean since v11.0.0: https://github.com/nodejs/node/commit/4b00c4fafaa2ae8c41c1f78823c0feb810ae4723#diff-e3bc37430eb078ccbafe3aa3b570c91a\n\n  const isAborted = () => typeof currentRequest.aborted === 'number' || currentRequest.aborted;\n\n  const emitError = async error => {\n    try {\n      for (const hook of options.hooks.beforeError) {\n        // eslint-disable-next-line no-await-in-loop\n        error = await hook(error);\n      }\n\n      emitter.emit('error', error);\n    } catch (error_) {\n      emitter.emit('error', error_);\n    }\n  };\n\n  const get = async () => {\n    let httpOptions = await normalize_arguments_1.normalizeRequestArguments(options);\n\n    const handleResponse = async response => {\n      var _a;\n\n      try {\n        /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n        if (options.useElectronNet) {\n          response = new Proxy(response, {\n            get: (target, name) => {\n              if (name === 'trailers' || name === 'rawTrailers') {\n                return [];\n              }\n\n              const value = target[name];\n              return is_1.default.function_(value) ? value.bind(target) : value;\n            }\n          });\n        }\n\n        const typedResponse = response;\n        const {\n          statusCode\n        } = typedResponse;\n        typedResponse.statusMessage = is_1.default.nonEmptyString(typedResponse.statusMessage) ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = requestUrl;\n        typedResponse.retryCount = retryCount;\n        typedResponse.redirectUrls = redirects;\n        typedResponse.request = {\n          options\n        };\n        typedResponse.isFromCache = (_a = typedResponse.fromCache, _a !== null && _a !== void 0 ? _a : false);\n        delete typedResponse.fromCache;\n\n        if (!typedResponse.isFromCache) {\n          typedResponse.ip = response.socket.remoteAddress;\n        }\n\n        const rawCookies = typedResponse.headers['set-cookie'];\n\n        if (Reflect.has(options, 'cookieJar') && rawCookies) {\n          let promises = rawCookies.map(async rawCookie => options.cookieJar.setCookie(rawCookie, typedResponse.url));\n\n          if (options.ignoreInvalidCookies) {\n            promises = promises.map(async p => p.catch(() => {}));\n          }\n\n          await Promise.all(promises);\n        }\n\n        if (options.followRedirect && Reflect.has(typedResponse.headers, 'location') && redirectCodes.has(statusCode)) {\n          typedResponse.resume(); // We're being redirected, we don't care about the response.\n\n          if (statusCode === 303 || options.methodRewriting === false) {\n            if (options.method !== 'GET' && options.method !== 'HEAD') {\n              // Server responded with \"see other\", indicating that the resource exists at another location,\n              // and the client should request it from that location via GET or HEAD.\n              options.method = 'GET';\n            }\n\n            if (Reflect.has(options, 'body')) {\n              delete options.body;\n            }\n\n            if (Reflect.has(options, 'json')) {\n              delete options.json;\n            }\n\n            if (Reflect.has(options, 'form')) {\n              delete options.form;\n            }\n          }\n\n          if (redirects.length >= options.maxRedirects) {\n            throw new errors_1.MaxRedirectsError(typedResponse, options.maxRedirects, options);\n          } // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n\n\n          const redirectBuffer = Buffer.from(typedResponse.headers.location, 'binary').toString();\n          const redirectUrl = new url_1.URL(redirectBuffer, options.url); // Redirecting to a different site, clear cookies.\n\n          if (redirectUrl.hostname !== options.url.hostname && Reflect.has(options.headers, 'cookie')) {\n            delete options.headers.cookie;\n          }\n\n          redirects.push(redirectUrl.toString());\n          options.url = redirectUrl;\n\n          for (const hook of options.hooks.beforeRedirect) {\n            // eslint-disable-next-line no-await-in-loop\n            await hook(options, typedResponse);\n          }\n\n          emitter.emit('redirect', response, options);\n          await get();\n          return;\n        }\n\n        await get_response_1.default(typedResponse, options, emitter);\n      } catch (error) {\n        emitError(error);\n      }\n    };\n\n    const handleRequest = async request => {\n      let isPiped = false;\n      let isFinished = false; // `request.finished` doesn't indicate whether this has been emitted or not\n\n      request.once('finish', () => {\n        isFinished = true;\n      });\n      currentRequest = request;\n\n      const onError = error => {\n        if (error instanceof timed_out_1.TimeoutError) {\n          error = new errors_1.TimeoutError(error, request.timings, options);\n        } else {\n          error = new errors_1.RequestError(error, options);\n        }\n\n        if (!emitter.retry(error)) {\n          emitError(error);\n        }\n      };\n\n      request.on('error', error => {\n        if (isPiped) {\n          // Check if it's caught by `stream.pipeline(...)`\n          if (!isFinished) {\n            return;\n          } // We need to let `TimedOutTimeoutError` through, because `stream.pipeline(…)` aborts the request automatically.\n\n\n          if (isAborted() && !(error instanceof timed_out_1.TimeoutError)) {\n            return;\n          }\n        }\n\n        onError(error);\n      });\n\n      try {\n        http_timer_1.default(request);\n        timed_out_1.default(request, options.timeout, options.url);\n        emitter.emit('request', request);\n        const uploadStream = progress_1.createProgressStream('uploadProgress', emitter, httpOptions.headers['content-length']);\n        isPiped = true;\n        await pipeline(httpOptions.body, uploadStream, request);\n        request.emit('upload-complete');\n      } catch (error) {\n        if (isAborted() && error.message === 'Premature close') {\n          // The request was aborted on purpose\n          return;\n        }\n\n        onError(error);\n      }\n    };\n\n    if (options.cache) {\n      // `cacheable-request` doesn't support Node 10 API, fallback.\n      httpOptions = { ...httpOptions,\n        ...url_to_options_1.default(options.url)\n      }; // @ts-ignore `cacheable-request` has got invalid types\n\n      const cacheRequest = options.cacheableRequest(httpOptions, handleResponse);\n      cacheRequest.once('error', error => {\n        if (error instanceof CacheableRequest.RequestError) {\n          emitError(new errors_1.RequestError(error, options));\n        } else {\n          emitError(new errors_1.CacheError(error, options));\n        }\n      });\n      cacheRequest.once('request', handleRequest);\n    } else {\n      // Catches errors thrown by calling `requestFn(…)`\n      try {\n        handleRequest(httpOptions[types_1.requestSymbol](options.url, httpOptions, handleResponse));\n      } catch (error) {\n        emitError(new errors_1.RequestError(error, options));\n      }\n    }\n  };\n\n  emitter.retry = error => {\n    let backoff;\n    retryCount++;\n\n    try {\n      backoff = options.retry.calculateDelay({\n        attemptCount: retryCount,\n        retryOptions: options.retry,\n        error,\n        computedValue: calculate_retry_delay_1.default({\n          attemptCount: retryCount,\n          retryOptions: options.retry,\n          error,\n          computedValue: 0\n        })\n      });\n    } catch (error_) {\n      emitError(error_);\n      return false;\n    }\n\n    if (backoff) {\n      const retry = async options => {\n        try {\n          for (const hook of options.hooks.beforeRetry) {\n            // eslint-disable-next-line no-await-in-loop\n            await hook(options, error, retryCount);\n          }\n\n          await get();\n        } catch (error_) {\n          emitError(error_);\n        }\n      };\n\n      setTimeout(retry, backoff, { ...options,\n        forceRefresh: true\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  emitter.abort = () => {\n    emitter.prependListener('request', request => {\n      request.abort();\n    });\n\n    if (currentRequest) {\n      currentRequest.abort();\n    }\n  };\n\n  (async () => {\n    // Promises are executed immediately.\n    // If there were no `setImmediate` here,\n    // `promise.json()` would have no effect\n    // as the request would be sent already.\n    await setImmediateAsync();\n\n    try {\n      for (const hook of options.hooks.beforeRequest) {\n        // eslint-disable-next-line no-await-in-loop\n        await hook(options);\n      }\n\n      await get();\n    } catch (error) {\n      emitError(error);\n    }\n  })();\n\n  return emitter;\n};\n\nexports.proxyEvents = (proxy, emitter) => {\n  const events = ['request', 'redirect', 'uploadProgress', 'downloadProgress'];\n\n  for (const event of events) {\n    emitter.on(event, (...args) => {\n      proxy.emit(event, ...args);\n    });\n  }\n};","map":{"version":3,"sources":["/Users/js/Dev/my-first-reactor/node_modules/got/dist/source/request-as-event-emitter.js"],"names":["Object","defineProperty","exports","value","CacheableRequest","require","EventEmitter","http","stream","url_1","util_1","is_1","http_timer_1","calculate_retry_delay_1","errors_1","get_response_1","normalize_arguments_1","progress_1","timed_out_1","types_1","url_to_options_1","setImmediateAsync","Promise","resolve","setImmediate","pipeline","promisify","redirectCodes","Set","default","options","emitter","requestUrl","url","toString","redirects","retryCount","currentRequest","isAborted","aborted","emitError","error","hook","hooks","beforeError","emit","error_","get","httpOptions","normalizeRequestArguments","handleResponse","response","_a","useElectronNet","Proxy","target","name","function_","bind","typedResponse","statusCode","statusMessage","nonEmptyString","STATUS_CODES","redirectUrls","request","isFromCache","fromCache","ip","socket","remoteAddress","rawCookies","headers","Reflect","has","promises","map","rawCookie","cookieJar","setCookie","ignoreInvalidCookies","p","catch","all","followRedirect","resume","methodRewriting","method","body","json","form","length","maxRedirects","MaxRedirectsError","redirectBuffer","Buffer","from","location","redirectUrl","URL","hostname","cookie","push","beforeRedirect","handleRequest","isPiped","isFinished","once","onError","TimeoutError","timings","RequestError","retry","on","timeout","uploadStream","createProgressStream","message","cache","cacheRequest","cacheableRequest","CacheError","requestSymbol","backoff","calculateDelay","attemptCount","retryOptions","computedValue","beforeRetry","setTimeout","forceRefresh","abort","prependListener","beforeRequest","proxyEvents","proxy","events","event","args"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CacheableRequest = require(\"cacheable-request\");\nconst EventEmitter = require(\"events\");\nconst http = require(\"http\");\nconst stream = require(\"stream\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"util\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst http_timer_1 = require(\"@szmarczak/http-timer\");\nconst calculate_retry_delay_1 = require(\"./calculate-retry-delay\");\nconst errors_1 = require(\"./errors\");\nconst get_response_1 = require(\"./get-response\");\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\nconst progress_1 = require(\"./progress\");\nconst timed_out_1 = require(\"./utils/timed-out\");\nconst types_1 = require(\"./types\");\nconst url_to_options_1 = require(\"./utils/url-to-options\");\nconst setImmediateAsync = async () => new Promise(resolve => setImmediate(resolve));\nconst pipeline = util_1.promisify(stream.pipeline);\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nexports.default = (options) => {\n    const emitter = new EventEmitter();\n    const requestUrl = options.url.toString();\n    const redirects = [];\n    let retryCount = 0;\n    let currentRequest;\n    // `request.aborted` is a boolean since v11.0.0: https://github.com/nodejs/node/commit/4b00c4fafaa2ae8c41c1f78823c0feb810ae4723#diff-e3bc37430eb078ccbafe3aa3b570c91a\n    const isAborted = () => typeof currentRequest.aborted === 'number' || currentRequest.aborted;\n    const emitError = async (error) => {\n        try {\n            for (const hook of options.hooks.beforeError) {\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n            emitter.emit('error', error);\n        }\n        catch (error_) {\n            emitter.emit('error', error_);\n        }\n    };\n    const get = async () => {\n        let httpOptions = await normalize_arguments_1.normalizeRequestArguments(options);\n        const handleResponse = async (response) => {\n            var _a;\n            try {\n                /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n                if (options.useElectronNet) {\n                    response = new Proxy(response, {\n                        get: (target, name) => {\n                            if (name === 'trailers' || name === 'rawTrailers') {\n                                return [];\n                            }\n                            const value = target[name];\n                            return is_1.default.function_(value) ? value.bind(target) : value;\n                        }\n                    });\n                }\n                const typedResponse = response;\n                const { statusCode } = typedResponse;\n                typedResponse.statusMessage = is_1.default.nonEmptyString(typedResponse.statusMessage) ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n                typedResponse.url = options.url.toString();\n                typedResponse.requestUrl = requestUrl;\n                typedResponse.retryCount = retryCount;\n                typedResponse.redirectUrls = redirects;\n                typedResponse.request = { options };\n                typedResponse.isFromCache = (_a = typedResponse.fromCache, (_a !== null && _a !== void 0 ? _a : false));\n                delete typedResponse.fromCache;\n                if (!typedResponse.isFromCache) {\n                    typedResponse.ip = response.socket.remoteAddress;\n                }\n                const rawCookies = typedResponse.headers['set-cookie'];\n                if (Reflect.has(options, 'cookieJar') && rawCookies) {\n                    let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, typedResponse.url));\n                    if (options.ignoreInvalidCookies) {\n                        promises = promises.map(async (p) => p.catch(() => { }));\n                    }\n                    await Promise.all(promises);\n                }\n                if (options.followRedirect && Reflect.has(typedResponse.headers, 'location') && redirectCodes.has(statusCode)) {\n                    typedResponse.resume(); // We're being redirected, we don't care about the response.\n                    if (statusCode === 303 || options.methodRewriting === false) {\n                        if (options.method !== 'GET' && options.method !== 'HEAD') {\n                            // Server responded with \"see other\", indicating that the resource exists at another location,\n                            // and the client should request it from that location via GET or HEAD.\n                            options.method = 'GET';\n                        }\n                        if (Reflect.has(options, 'body')) {\n                            delete options.body;\n                        }\n                        if (Reflect.has(options, 'json')) {\n                            delete options.json;\n                        }\n                        if (Reflect.has(options, 'form')) {\n                            delete options.form;\n                        }\n                    }\n                    if (redirects.length >= options.maxRedirects) {\n                        throw new errors_1.MaxRedirectsError(typedResponse, options.maxRedirects, options);\n                    }\n                    // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n                    const redirectBuffer = Buffer.from(typedResponse.headers.location, 'binary').toString();\n                    const redirectUrl = new url_1.URL(redirectBuffer, options.url);\n                    // Redirecting to a different site, clear cookies.\n                    if (redirectUrl.hostname !== options.url.hostname && Reflect.has(options.headers, 'cookie')) {\n                        delete options.headers.cookie;\n                    }\n                    redirects.push(redirectUrl.toString());\n                    options.url = redirectUrl;\n                    for (const hook of options.hooks.beforeRedirect) {\n                        // eslint-disable-next-line no-await-in-loop\n                        await hook(options, typedResponse);\n                    }\n                    emitter.emit('redirect', response, options);\n                    await get();\n                    return;\n                }\n                await get_response_1.default(typedResponse, options, emitter);\n            }\n            catch (error) {\n                emitError(error);\n            }\n        };\n        const handleRequest = async (request) => {\n            let isPiped = false;\n            let isFinished = false;\n            // `request.finished` doesn't indicate whether this has been emitted or not\n            request.once('finish', () => {\n                isFinished = true;\n            });\n            currentRequest = request;\n            const onError = (error) => {\n                if (error instanceof timed_out_1.TimeoutError) {\n                    error = new errors_1.TimeoutError(error, request.timings, options);\n                }\n                else {\n                    error = new errors_1.RequestError(error, options);\n                }\n                if (!emitter.retry(error)) {\n                    emitError(error);\n                }\n            };\n            request.on('error', error => {\n                if (isPiped) {\n                    // Check if it's caught by `stream.pipeline(...)`\n                    if (!isFinished) {\n                        return;\n                    }\n                    // We need to let `TimedOutTimeoutError` through, because `stream.pipeline(…)` aborts the request automatically.\n                    if (isAborted() && !(error instanceof timed_out_1.TimeoutError)) {\n                        return;\n                    }\n                }\n                onError(error);\n            });\n            try {\n                http_timer_1.default(request);\n                timed_out_1.default(request, options.timeout, options.url);\n                emitter.emit('request', request);\n                const uploadStream = progress_1.createProgressStream('uploadProgress', emitter, httpOptions.headers['content-length']);\n                isPiped = true;\n                await pipeline(httpOptions.body, uploadStream, request);\n                request.emit('upload-complete');\n            }\n            catch (error) {\n                if (isAborted() && error.message === 'Premature close') {\n                    // The request was aborted on purpose\n                    return;\n                }\n                onError(error);\n            }\n        };\n        if (options.cache) {\n            // `cacheable-request` doesn't support Node 10 API, fallback.\n            httpOptions = {\n                ...httpOptions,\n                ...url_to_options_1.default(options.url)\n            };\n            // @ts-ignore `cacheable-request` has got invalid types\n            const cacheRequest = options.cacheableRequest(httpOptions, handleResponse);\n            cacheRequest.once('error', (error) => {\n                if (error instanceof CacheableRequest.RequestError) {\n                    emitError(new errors_1.RequestError(error, options));\n                }\n                else {\n                    emitError(new errors_1.CacheError(error, options));\n                }\n            });\n            cacheRequest.once('request', handleRequest);\n        }\n        else {\n            // Catches errors thrown by calling `requestFn(…)`\n            try {\n                handleRequest(httpOptions[types_1.requestSymbol](options.url, httpOptions, handleResponse));\n            }\n            catch (error) {\n                emitError(new errors_1.RequestError(error, options));\n            }\n        }\n    };\n    emitter.retry = error => {\n        let backoff;\n        retryCount++;\n        try {\n            backoff = options.retry.calculateDelay({\n                attemptCount: retryCount,\n                retryOptions: options.retry,\n                error,\n                computedValue: calculate_retry_delay_1.default({\n                    attemptCount: retryCount,\n                    retryOptions: options.retry,\n                    error,\n                    computedValue: 0\n                })\n            });\n        }\n        catch (error_) {\n            emitError(error_);\n            return false;\n        }\n        if (backoff) {\n            const retry = async (options) => {\n                try {\n                    for (const hook of options.hooks.beforeRetry) {\n                        // eslint-disable-next-line no-await-in-loop\n                        await hook(options, error, retryCount);\n                    }\n                    await get();\n                }\n                catch (error_) {\n                    emitError(error_);\n                }\n            };\n            setTimeout(retry, backoff, { ...options, forceRefresh: true });\n            return true;\n        }\n        return false;\n    };\n    emitter.abort = () => {\n        emitter.prependListener('request', (request) => {\n            request.abort();\n        });\n        if (currentRequest) {\n            currentRequest.abort();\n        }\n    };\n    (async () => {\n        // Promises are executed immediately.\n        // If there were no `setImmediate` here,\n        // `promise.json()` would have no effect\n        // as the request would be sent already.\n        await setImmediateAsync();\n        try {\n            for (const hook of options.hooks.beforeRequest) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(options);\n            }\n            await get();\n        }\n        catch (error) {\n            emitError(error);\n        }\n    })();\n    return emitter;\n};\nexports.proxyEvents = (proxy, emitter) => {\n    const events = [\n        'request',\n        'redirect',\n        'uploadProgress',\n        'downloadProgress'\n    ];\n    for (const event of events) {\n        emitter.on(event, (...args) => {\n            proxy.emit(event, ...args);\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}